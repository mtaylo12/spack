#defined literal_not_solved/1.

#defined error/2.
#defined error/3.
#defined error/4.
#defined error/5.
#defined error/6.
#defined error/7.

#defined compiler_mismatch/2.
#defined node_target_mismatch/2.
#defined node_os_mismatch/2.
#defined compiler_mismatch_required/2.

#defined requirement_has_weight/2.
#defined requirement_weight/2.

%-----------------------------------------------------------------
% Constants necessary for final state
%-----------------------------------------------------------------
#const max_error_priority = 3.
#const error_prio = 10000000.
#const solve_prio = 1000000.
#const build_prio = 100000.  % n_nodes x depth_offset x max levels needs to be less than this
#const depth_offset = 100.   % depth_offset-1 is the max id for leveled criteria


opt_criterion(solve_prio, "fixed", "number of input specs not concretized").
#minimize{ 0@solve_prio: #true }.
#minimize{ 1@solve_prio,ID : literal_not_solved(ID) }.

%-----------------------------------------------------------------
% Depth recomputation
%-----------------------------------------------------------------
% roots have depth 0.
depth(Package, 0) :- attr("root", Package).

% other nodes' depth is the minimum depth of any dependent plus one.    
depth(Package, N + 1) :-
		N = #min{
						D: depends_on(Dependent, Package),
						depth(Dependent, D),
						D < max_depth;
						max_depth - 1
				},
		N = 0..max_depth - 1,
		attr("node", Package).       




%-----------------------------------------------------------------
% Optimization to avoid errors
%-----------------------------------------------------------------
% Some errors are handled as rules instead of constraints because
% it allows us to explain why something failed. Here we optimize
% HEAVILY against the facts generated by those rules.

% ensure that error costs are always in the solution.
#minimize{ 0@error_prio + (0..max_error_priority): #true}.

%% % TODO: why 1000 and not just 1? 1000 seems unnecessary since priorities are lexicographic.
#minimize{ 1000@error_prio+Priority,Msg: error(Priority, Msg) }.
#minimize{ 1000@error_prio+Priority,Msg,Arg1: error(Priority, Msg, Arg1) }.
#minimize{ 1000@error_prio+Priority,Msg,Arg1,Arg2: error(Priority, Msg, Arg1, Arg2) }.
#minimize{ 1000@error_prio+Priority,Msg,Arg1,Arg2,Arg3: error(Priority, Msg, Arg1, Arg2, Arg3) }.
#minimize{ 1000@error_prio+Priority,Msg,Arg1,Arg2,Arg3,Arg4: error(Priority, Msg, Arg1, Arg2, Arg3, Arg4) }.
#minimize{ 1000@error_prio+Priority,Msg,Arg1,Arg2,Arg3,Arg4,Arg5: error(Priority, Msg, Arg1, Arg2, Arg3, Arg4, Arg5) }.


% Ensure that values are returned by clingo for every distinct optimization criterion.
% Some criteria are "fixed" and have only one bucket. Others are summed into multiple
% buckets -- per build priority and per depth in the graph.
% If we don't do this, it's very hard to read the sums back. We use `0@...` because
% it doesn't affect the sums -- it just ensure that clingo returns them.

% "fixed" criteria have one bucket -- their priority.
#minimize{ 0@N: opt_criterion(N, "fixed", _) }.

% "leveled" criteria sum into a bucket per depth in the graph, per build priority
#minimize{
    0@(((max_depth - D - 1) * depth_offset) + N + build_prio)
    : opt_criterion(N, "leveled", _), depth(_, D)
}.
#minimize{
    0@(((max_depth - D - 1) * depth_offset) + N)
    : opt_criterion(N, "leveled", _), depth(_, D)
}.

% Try hard to reuse installed packages (i.e., minimize the number built)
opt_criterion(build_prio, "fixed", "number of packages to build (vs. reuse)").
#minimize { 1@build_prio,Package : build(Package), optimize_for_reuse() }.
%#defined optimize_for_reuse/0.


% A condition group specifies one or more specs that must be satisfied.
% Specs declared first are preferred, so we assign increasing weights and
% minimize the weights.
opt_criterion(65, "leveled", "requirement weight").
#minimize{
    Weight@(65 + ((max_depth - D - 1) * depth_offset) + Priority), Package
    : requirement_weight(Package, Weight),
      build_priority(Package, Priority),
      depth(Package, D)
}.

opt_criterion(60, "leveled", "deprecated versions used").
#minimize{
    1@(60 + ((max_depth - D - 1) * depth_offset) + Priority), Package
    : attr("deprecated", Package, _),
      build_priority(Package, Priority),
      depth(Package, D)
}.

opt_criterion(55, "leveled", "version badness").
#minimize{
    Weight@(55 + ((max_depth - D - 1) * depth_offset) + Priority), Package
    : version_weight(Package, Weight),
      build_priority(Package, Priority),
      depth(Package, D)
}.

opt_criterion(50, "leveled", "number of non-default variants").
#minimize{
    1@(50 + ((max_depth - D - 1) * depth_offset) + Priority), Package, Variant, Value
    : variant_not_default(Package, Variant, Value),
      build_priority(Package, Priority),
      depth(Package, D)
}.

opt_criterion(45, "leveled", "preferred providers").
#minimize{
    Weight@(45 + ((max_depth - D - 1) * depth_offset) + Priority), Provider, Virtual
    : provider_weight(Provider, Virtual, Weight),
      build_priority(Provider, Priority),
      depth(Package, D)
}.

opt_criterion(40, "leveled", "default values of variants not being used").
#minimize{
    1@(40 + ((max_depth - D - 1) * depth_offset) + Priority), Package, Variant, Value
    : variant_default_not_used(Package, Variant, Value),
      build_priority(Package, Priority),
      depth(Package, D)
}.

opt_criterion(35, "leveled", "compiler mismatches (not from CLI)").
#minimize{
    1@(35 + ((max_depth - D - 1) * depth_offset) + Priority), Dependent, Package
    : compiler_mismatch(Dependent, Package),
      build_priority(Package, Priority),
      depth(Package, D)
}.

opt_criterion(30, "leveled", "compiler mismatches (from CLI)").
#minimize{
    1@(30 + ((max_depth - D - 1) * depth_offset) + Priority), Dependent, Package
    : compiler_mismatch_required(Dependent, Package),
      build_priority(Package, Priority),
      depth(Package, D)
}.

opt_criterion(25, "leveled", "OS mismatches").
#minimize{
    1@(25 + ((max_depth - D - 1) * depth_offset) + Priority), Dependent, Package
    : node_os_mismatch(Dependent, Package),
      build_priority(Package, Priority),
      depth(Package, D)
}.

opt_criterion(20, "leveled", "non-preferred compilers").
#minimize{
    Weight@(20 + ((max_depth - D - 1) * depth_offset) + Priority), Package
    : compiler_weight(Package, Weight),
      build_priority(Package, Priority),
      depth(Package, D)
}.

opt_criterion(15, "leveled", "non-preferred OS's").
#minimize{
    Weight@(15 + ((max_depth - D - 1) * depth_offset) + Priority), Package
    : node_os_weight(Package, Weight),
      build_priority(Package, Priority),
      depth(Package, D)
}.

% Minimize the number of mismatches for targets in the DAG, try
% to select the preferred target.
opt_criterion(10, "leveled", "target mismatches").
#minimize{
    1@(10 + ((max_depth - D - 1) * depth_offset) + Priority), Dependent, Package
    : node_target_mismatch(Dependent, Package),
      build_priority(Package, Priority),
      depth(Package, D)
}.

opt_criterion(5, "leveled", "non-preferred targets").
#minimize{
    Weight@(5 + ((max_depth - D - 1) * depth_offset) + Priority), Package
    : node_target_weight(Package, Weight),
      build_priority(Package, Priority),
      depth(Package, D)
}.

																																																																																																									 
%#show attr/3.
%#show attr/4.

%#show error/2.
%#show error/3.
%#show error/4.
%#show error/5.
%#show error/6.
%#show error/7.

% depths
%#show depth/2.
%#show parent_depth/2.

% debug

%#show depends_on/2.

%node(Package) :- attr("node", Package).
%#show node/1.

%version(Package, Version) :- attr("version", Package, Version).
%#show version/2.


